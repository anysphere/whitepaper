\section{Core Protocol}
\label{sec:coreprotocol}

sConsider two fictional users Alice and Bob. Alice and Bob wish to message each other over an untrusted network, without leaking any data or metadata to anyone. To hide the message content, they use end-to-end encryption. To hide metadata, they employ two key ideas: sending data at a constant rate, and retrieving homomorphically compressed data.

When signing up, each user gets their own \textit{outbox} on the server, which serves as a dedicated storage space for the user's message. Once every minute, Alice sends exactly 1 KB of data to her outbox on the server. If she has a message to send, she sends the padded encryption of that message. Otherwise, she sends a random sequence of bytes encrypted with a random key. This simple idea ensures that the server and any network observers will not know when Alice actually sends a message.

The message needs to be routed to Bob. An E2E messaging system would have Bob download data from Alice's outbox, and then try to decrypt it. But the server would know that Bob read from the outbox Alice wrote to, which links them together and exposes metadata!

One solution is for Bob to download \textbf{all} outboxes once every minute, and check Alice's outbox locally. The servers have no way of linking Alice to Bob, and all metadata is protected.

This is not quite how Anysphere works. Obviously, downloading all outboxes every minute incurs prohibitive network costs, so instead Bob uses \textit{private information retrieval}(PIR), a well-studied cryptographic scheme to compress his download size. \Cref{fig:highlevelpir} illustrates the core protocol. The following subsections will describe the system in detail.

% make this take up both columns at the top of the page
\begin{figure}
    \centering
    \includegraphics[width=0.7\textwidth]{pirfigure.pdf}
\caption{Alice sends the encryption of a 1 KB message $m$ to her outbox once every minute. Bob retrieves Alice's outbox using private information retrieval (PIR), which appears to everyone else but Bob as if he had not downloaded anything. Alice and Bob can use standard symmetric encryption to communicate, and the server will not learn anything at all.}
\label{fig:highlevelpir}
\end{figure}



\subsection{Private information retrieval}

We wiew the outboxes as an array $\db$. Bob wants to download Alice's outbox $\db[i]$ without revealing $i$ to anyone. This problem was first introduced as \textit{private information retrieval} (PIR) in 1995 \cite{chor1995private}, extended in 1997 to our threat model under the name cPIR \cite{kushilevitz1997replication}, and has been extensively studied since then \cite{melchor2016xpir,angel2018pir, ahmad2021addra}.

All known cPIR schemes use homomorphic encryption \cite{gentry2010computing}. To compute the query $q$, Bob encrypts $i$ with a homomorphic encryption scheme using a secret key $s$. That is, $q = \mathsf{HEnc}_s(i)$. The server can then homomorphically evaluate the function $f(i) = \db[i]$, producing the answer $a = \mathsf{HEnc}_s(\db[i])$. Bob can finally decrypt to find $\db[i]$. In practice, $f(i)$ is often defined in terms of a dot product with a unit vector representing $i$, because BFV, the homomorphic scheme being used, \cite{fan2012somewhat}, is particularly good at dot products.

Our implementation currently uses FastPIR, which is one of the fastest cPIR schemes \cite{ahmad2021addra}. All cPIR schemes have the same security properties (i.e., they leak zero information), and we are actively researching faster schemes (see \cref{sec:future}).

\subsection{Security}

The simplest version of our core protocol is shown in \cref{fig:simple}. In this section, we show (1) that Alice and Bob enjoy complete metadata-privacy without having to trust anyone else, and (2) that our protocol is resistant to denial of service attacks from users.



% We define security in the simulation sense, which is a common way to define security in the cryptographic community \cite{lindell2017simulate}. To do so, we first need to define what an attacker learns, which includes both the data sent from all users to the server along with timestamps, as well as the local keys on attacker-controlled devices. Let $(S, i, \mathsf{tk}, c, t)$ represent the data sent to the server in the sending phase at time $t$, and let $(R, q, t)$ represent the data sent to the server in the retrieving phase at time $t$. Our protocol does not operate in rounds, so $t$ can be any real number. We can now define security.

% \begin{definition}[Security]
%     We say that a private communication scheme $(\mathsf{Send}, \mathsf{Receive}, \mathsf{Route})$ is \textit{secure} if for all $n = n_\lambda = \poly(\lambda)$, all $\mathcal{K} = \mathcal{K}_\lambda \subseteq [n]$, and efficient adversaries $\mathcal{A}$, there exists an efficient algorithm $\mathsf{Sim}$, such that the following two probability ensembles, parametrized by $\lambda \in \N$, are computationally indistinguishable:
%     \begin{align*}
%         \Dreal &= \left\{ 
%         \begin{aligned}
%           (\pi, \pk, \{ \sk_i \mid i \in \calK \}) &\colon \\
%           \pi &\getsr \Perms(n)\\
%           (\pk, \sk_1, \dots, \sk_n) &\gets \setup(1^\lambda, \pi)
%         \end{aligned}\right\}_{\lambda \in \N}\\
%         \Dideal &= \left\{
%         \begin{aligned}
%           (\pi, \,\Sim\big(1^\lambda, \{(i, \pi(i)) \mid &\pi(i) \in \calK\}\big)\, ) \colon \\
%           \pi &\getsr \Perms(n) 
%         \end{aligned}
%           \right\}_{\lambda \in \N}.
%       \end{align*}
% \end{definition}

% \todo{simulation security definition, going offline, friend attack, key privacy because prf.}

\textbf{Going offline.} Users will not always be connected to the internet. At night, most people put their computers to sleep. This means that users will not be sending and receiving exactly once every minute. \xxx{how much information does this leak?} \xxx[stzh]{However, as long as users make their connection schedule regular(e.g. transmits from 9AM to 5PM each day), no metadata is leaked. <- this is not a good argument, esp. for emergencies}

\textbf{Authentication token.} 
On registration, the server creates a unique authentication token for the new user. This allows the server to restrict access to that user's outbox, preventing denial of service attacks from other users. It should still be noted that, in accordance with our threat model, we do not prevent against denial of service attacks by ISPs or the server itself — fundamentally, a powerful actor can always shut down your internet access. In \cref{sec:future} we discuss plans for distributing the server such that, say, only 1 out of 3 servers need to be trusted to provide service.

\begin{figure}
    \begin{framed}
    {\raggedright
        \small
    
    \begin{hangparas}{1em}{1}
    
        \hrule
        \vspace{0.15cm}
        \textsc{\textbf{Protocol $\protocolNumber$: Anysphere Core Protocol}}
        \vspace{0.1cm}
        \hrule
        \vspace{0.1cm}
        \medskip

        \textbf{Registration.}
            Server allocates outbox $i$ and generates authentication token $\authtoken$.
            Alice receives $(i, \authtoken)$.
    
    \medskip

        \textbf{Trust establishment.}
            Alice and Bob agree on a shared secret key $k$. Details in \cref{sec:trustestablishment}.

            \medskip

        \textbf{Sending.}
            Exactly once every minute: \begin{itemize}
                \item If Alice has a queued message $m$: she sends $(i, \authtoken, \enc_k(m))$ to the server, where $k$ is the key shared with Bob.
                \item Otherwise: she sends $(i, \authtoken, r)$ to the server, where $r$ is a random sequence of bytes.
            \end{itemize}
            The server receives $(i, \authtoken, c)$ and stores $c$ in outbox $i$ if $\authtoken$ is correct.

    \medskip

        
        \textbf{Receiving.} Exactly once every minute:
      \begin{itemize}
        \item Bob sends $q = \query(i)$ to the server.
        \item The server responds with $a = \answer(\db, q)$ and Bob decodes it into $c = \decode(a)$.
        \item Bob tries to decrypt $\dec_k(c)$ using the shared secret key $k$.
      \end{itemize}
    \end{hangparas}
    }
    \end{framed}
    \caption{The simplest version of our core protocol.}
    \label{fig:simple}
\end{figure}

\subsection{Multiple contacts}

The simple protocol from before assumed Alice had a single contact Bob. Our system allows many more contacts. 
\xxx{link the compromised friend attack}

\subsection{Chunks and ACKs}

If Alice wants to send a message longer than 1 KB, she needs to separate the message into 1KB ``chunks" and deliver all chunks to Bob in separate PIR transmissions. To ensure successful delivery, we took inspiration from TCP/IP. Each message from Alice to Bob is labeled with a integer message identifier $m$. Each chunk of message $m$ is further labeled with a sequence number starting from $1$. When Bob receives chunk $c$ of message $m$, he sends Alice a short acknowledgement(ACK) message $ACK(m, c)$ over a separate ACK PIR table. Alice listens to Bob's ACK message using PIR, and deposits chunk $c + 1$ of message $i$ only after reading $ACK(m, c)$ from Bob.

Each ACK message only needs to encode two integers $m, c$. Thus, reading ACKs represents a much lighter load compared to the main message database.

%\xxx{describe the separate PIR table for ACKs.}

\begin{figure}
    \centering
    \includegraphics[width=0.7\textwidth]{ACK.pdf}
\caption{All server interactions for a message from Alice to Bob}
\label{fig:highlevelpir}
\end{figure}

\xxx{Figure: pseudocode for Register, Send, Retrieve (with everything)}