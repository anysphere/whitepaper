\newpage
\section{Trust Establishment}
\label{sec:trustestablishment}

The Anysphere Core protocol's first phase requires participants to make contact. ``Trust Establishment", \cite{unger2015sok}, is a notoriously difficult problem, where users exchange long-term keys and ensure they're talking to their intended contacts. For Anysphere to always be metadata-secure, we need a metadata-secure trust establishment procedure.

In practice, Alice needs to find Bob's public key and use it to send an ``Invitation" to Bob. Bob must be able to retrieve this invitation and complete a key exchange with Alice. Most importantly, the server should not learn any metadata of this exchange. 

We provide two alternate methods of trust establishment designed for our users that meet our desired security profile and don't have prohibitive computational costs. The first of our methods is for security-conscious users, and the other allows the advantage of remote participants. In the following two methods, we assume Alice and Bob have a Curve25519 key exchange key pair $kx = (kx^P, kx^S)$ and aim to inform each other of their $kx^P$ to derive a shared secret $sk$. \xxx[Sualeh]{Handle the part about why we do not include the username in the publicID.}

% \cite{liutromer2021} discusses this as the Oblivious Message Detection(OMD) problem. Their proposed scheme aims to minimize user download size, and costs each user $\$ 1$ per million messages scanned, which is prohibitive for our messaging application. We provide two alternate methods of trust establishment with better computational cost and security \footnote{We should not appear to be strictly better than \cite{liutromer2021}; any ideas?}.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Sync Section %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \captionsetup[figure]{name=Protocol}
\begin{figure}[t]
  
  \begin{framed}
  {\raggedright
      \small
  
  \begin{hangparas}{1em}{1}
        \hrule
        \vspace{0.15cm}
        \textsc{\textbf{Protocol $\protocolNumber$: In-Person Trust Establishment}}
        \vspace{0.1cm}
        \hrule
        \vspace{0.1cm}
  \medskip
      
      \textbf{Encode.}
          Alice encodes the plaintext of her key exchange public key $kx_A^P$ and her allocation index $i_A$ into a human-readable story $s_A$. Bob similarly encodes his story $s_B$.

  \medskip

      \textbf{Share.}
          Alice and Bob meet. They share their stories, and type each other's story into their own client. 

          \medskip

      \textbf{Establish Contact.}
          Alice decodes Bob's story to obtain $kx^P_B$ and $i_B$. She computes the shared secret $sk = \DH(kx^P_B, kx^S_A)$, and adds $i_B$ to her set of listening indices.


  \end{hangparas}
  }
  \end{framed}
  \caption{Anysphere's protocol for establishing trust when the participants can talk to each other.}
  \label{fig:trust-establishment-inperson}
\end{figure}


\subsection{Face-to-face Invitations}

Alice and Bob establish trust in a face-to-face meeting,  either in-person or over zoom, and do a simple key exchange, as described in \cref{fig:trust-establishment-inperson}. They share the encoding of their keys as an English story of words.  All interactions between the users pass through no third party. Thus, trust establishment completes instantly, cheaply, and securely. It may seem prohibitive to set up a meeting and type manually, but we believe a privacy-conscious Alice would be willing to set up a meeting with Bob before sending him sensitive information.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Async Section %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[!th]
  \begin{framed}
  {\raggedright
      \small
  
  \begin{hangparas}{1em}{1}
        \hrule
        \vspace{0.15cm}
        \textsc{\textbf{Protocol $\protocolNumber$: Remote Trust Establishment}}
        \vspace{0.1cm}
        \hrule
        \vspace{0.1cm}
  \medskip
      
      \textbf{Send Invitation.}
      Alice initiates contact with Bob.
      \begin{enumerate}
          \item \textbf{Visibility.} Bob computes a ``public id" $id_B = (ki_B^P, kx_B^P, i_B)$, (where $ki_B^P$ is the invitation public key, $kx_B^P$ is the key exchange public key, and $i_B$ is the allocation). Bob posts $id_B$ on his public profile, such as on twitter.
          \item \textbf{Invitation.} Alice drafts a message $m_{AB}$ for Bob and obtains the triple $(ki_B^P, kx_B^P, i_B)$ from Bob's profile. She periodically sends the pair $(i_A, c_{AB} = \Enc(kx_B^P, id_A \vert m_{AB}))$ to the server, which stores it in a separate \textbf{AsyncInvitationDatabase}. When Alice has no invitations, her daemon sends $(i_A, \Enc(kx^P, id_A))$ for a random public key $kx^P$.
          \item \textbf{Invitation Message.} Alice computes a shared secret $sk =  \DH(kx_B^P, kx^S_A)$ with Bob. She then sends a message $inv_{AB}$ via our PIR transport layer, inviting Bob to join a conversation with her. Now, she listens for Bob's ACK.
      \end{enumerate}

  \medskip

      \textbf{Retrieve Invitation.}
        Bob receives Alice's invitation.
        \begin{enumerate}
            \item \textbf{Database Download.} Bob periodically downloads the entire \textbf{AsyncInvitationDatabase}.
            \item \textbf{Find Invitations.} Bob computes $\Dec(kx^S_B, c)$ over all key-value pairs $(i, c)$. If the decryption fails, Bob's daemon ignores this pair. If the decryption succeeds for the pair $(i, c) = (i_A, c_{AB})$, Bob decodes $i = i_A, id_A, m_{AB}$, and notices an invitation for him with message $m_{AB}$, and $id_A$.
            \item \textbf{Verify.} Bob needs to verify Alice's identity using $id_A$ and $m_{AB}$, say by checking Alice's profile. Bob now chooses to accept or reject the invitation.
        \end{enumerate}

    \medskip

      \textbf{Accept Invitation.}
          If Bob accepts Alice's invitation, he needs to respond to Alice.
          \begin{enumerate}
              \item \textbf{Decode.} Bob decodes $id_A = (ki_A^P, kx_A^P, i_A)$. He computes the shared secret $sk =  \DH(kx_B^P, kx^S_A)$ with Alice. He adds $i_A$ to the list of indices he listens to.
              \item \textbf{ACK.} Bob recieves the invitation message from Alice, $inv_{AB}$. Bob ACK's the message.
              \item Alice sees the ACK from Bob and now they can communicate over the PIR transport layer.
          \end{enumerate}
    \medskip
          
      \textbf{Reject Invitation.}
        If Bob rejects the invitation, no further action needs to be performed.
  \end{hangparas}
  }
  \end{framed}
  \caption{Anysphere's protocol for establishing trust when the participants are remote. Contact can be initiated only by a single participant and requires acknowledgement from both participants to establish successful contact}
  \label{fig:trust-establishment-async}
\end{figure}


\subsection{Asynchronous Invitations}
Alice and Bob can also establish trust asynchronously. Alice privately reaches out to Bob (possibly an organization) and wishes to send her invitation privately. She sends an encrypted invitation, without indicating the recipient. Bob retrieves this invitation via a full database download and informs Alice of his acceptance via an ACK message, as described in detail in \cref{fig:trust-establishment-async}.

To send an invitation, Alice learns Bob's information through a public platform like Twitter or his website. Alice quickly imports Bob's keys and sends two messages: one is an invitation through the Invitation Database for Bob to find her information, and a second message through the PIR transport layer for Bob to acknowledge.

To retrieve an invitation, Bob periodically downloads the entire Async Invitation Database and notices if there are invitations for him. The user(s) representing Bob's account choose whether to respond to the message, as would be the case in a traditional e-mail. If they choose to respond, they acknowledge Alice's message and can send a reply over the PIR transport layer.

This method achieves metadata security. We hide the timing of the invitation by making the daemon send to and download \textbf{AsyncInvitationDatabase} on a fixed schedule. 
We hide the recipient of Alice's request since our encryption scheme is key private(\todo{Cite Arvid's section}). 

This method offers a convenient trust establishment on par with most existing messaging platforms. 
Its disadvantage is that downloading the entire database is expensive. 
We estimate that a key-value pair in the \textbf{AsyncInvitationDatabase} take approximately $200\text{B}$. 
If we have 1 million users, the whole database will have a size of approximately $200\text{MB}$.
Thus, an individual user might wish only to download the database once or twice daily, which saves bandwidth but delays the detection of invitations. 
On the other hand, a company user could afford to download the database every second, which takes $200\text{MB}/s$ download bandwidth but can ensure incoming asynchronous invitations get detected almost instantly.

Finally, we note that this method introduces more attack vectors. For example, an attacker might use social engineering to make Alice believe that a fake $id_B$ belongs to Bob or simply monitor $A$'s traffic to $B$'s public profile. Therefore, we recommend that privacy-conscious users use face-to-face invitations whenever possible.

\xxx[Arvid]{Handle the part where we have to deal with Key Privacy.}