\section{Trust Establishment}
\label{sec:trustestablishment}

Most existing metadata private messaging systems, such as Pung or Addra, assume that users know beforehand who they wish to talk to, and had a prior key exchange through another channel. 
In our messaging application, we need a metadata-secure mechanism for the key exchange itself. 
In other words, if Alice knows Bob's public key, then Alice should be able to send an ``invitation" to Bob.  Bob must be able to retrieve this invitation from the server, and complete a key exchange with Alice. The server shouldn't learn any metadata of this exchange. We call this process ``trust establishment".

This problem is known as Oblivious Message Detection(OMD) in \cite{liutromer2021}. The scheme proposed in \cite{liutromer2021} aims to minimize user download size, but it costs each user $\$ 1$ per million messages scanned, which is prohibitive for our messaging application. We provide two alternate methods of trust establishment with better computational cost and security\footnote{We shouldn't appear to be strictly better than \cite{liutromer2021}; any ideas?}.

In the following two methods, we assume that Alice and Bob's daemons have generated a Curve25519 key exchange keypair $kx = (kx^P, kx^S)$. Their goal is to inform each other of their $kx^P$ to derive a shared secret $sk$.

\xxx[Sualeh]{Handle the part about why we do not include the username in the publicID.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Sync Section %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \captionsetup[figure]{name=Protocol}
\begin{figure}[t]
  
  \begin{framed}
  {\raggedright
      \small
  
  \begin{hangparas}{1em}{1}
        \hrule
        \vspace{0.15cm}
        \textsc{\textbf{Protocol $\protocolNumber$: In-Person Trust Establishment}}
        \vspace{0.1cm}
        \hrule
        \vspace{0.1cm}
  \medskip
      
      \textbf{Encode.}
          Alice encodes the plaintext of her key exchange public key $kx_A^P$ and her allocation index $i_A$ into a human-readable story $s_A$. Bob similarly encodes his story $s_B$.

  \medskip

      \textbf{Share.}
          Alice and Bob meet. They share their stories, and type the other's story into their own client. 

          \medskip

      \textbf{Establish Contact.}
          Alice decodes Bob's story to obtain $kx^P_B$ and $i_B$. She computes the shared secret $sk = DH(kx^P_B, kx^S_A)$, and adds $i_B$ to her set of listening indices.


  \end{hangparas}
  }
  \end{framed}
  \caption{Anysphere's protocol for establishing trust when the participants can talk to each other.}
  \label{fig:trust-establishment-inperson}
\end{figure}


\subsection{Face-to-face Invitations}

Our first method assumes that Alice and Bob are able to set up a face-to-face meeting with each other, either in person or over zoom. The trust establishment process is a simple key exchange implemented as described in \cref{fig:trust-establishment-inperson}.

Using this method, all interactions between the users do not pass through any third party. Thus, trust establishment can be completed instantly, cheaply, and securely. Our system does require Alice and Bob to be able to set up a meeting and type each other's story manually. To justify this approach, we believe a privacy-conscious Alice would be willing to set up a face-to-face meeting with Bob before sending him sensitive information.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Async Section %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[!th]
  \begin{framed}
  {\raggedright
      \small
  
  \begin{hangparas}{1em}{1}
        \hrule
        \vspace{0.15cm}
        \textsc{\textbf{Protocol $\protocolNumber$: Remote Trust Establishment}}
        \vspace{0.1cm}
        \hrule
        \vspace{0.1cm}
  \medskip
      
      \textbf{Send Invitation.}
      Alice initiates contact with Bob.
      \begin{enumerate}
          \item \textbf{Visibility.} Bob computes a ``public id" $id_B = (ki_B^P, kx_B^P, i_B)$, (where $ki_B^P$ is the invitation public key, $kx_B^P$ is the key exchange public key, and $i_B$ is the allocation). Bob posts $id_B$ on his public profile, such as on twitter.
          \item \textbf{Invitation.} Alice drafts a message $m_{AB}$ for Bob and obtains the triple $(ki_B^P, kx_B^P, i_B)$ from Bob's profile. She periodically sends the pair $(i_A, c_{AB} = \Enc(kx_B^P, id_A \vert m_{AB}))$ to the server, which stores it in a separate \textbf{AsyncInvitationDatabase}. When Alice has no invitations, her daemon sends $(i_A, \Enc(kx^P, id_A))$ for a random public key $kx^P$.
          \item \textbf{Invitation Message.} Alice computes a shared secret $sk =  \DH(kx_B^P, kx^S_A)$ with Bob. She then sends a message $inv_{AB}$ via our PIR transport layer, inviting Bob to join a conversation with her. Now, she listens for Bob's ACK.
      \end{enumerate}

  \medskip

      \textbf{Retrieve Invitation.}
        Bob receives Alice's invitation.
        \begin{enumerate}
            \item \textbf{Database Download.} Bob periodically downloads the entire \textbf{AsyncInvitationDatabase}.
            \item \textbf{Find Invitations.} Bob computes $\Dec(kx^S_B, c)$ over all key-value pairs $(i, c)$. If the decryption fails, Bob's daemon ignores this pair. If the decryption succeeds for the pair $(i, c) = (i_A, c_{AB})$, Bob decodes $i = i_A, id_A, m_{AB}$, and notices an invitation for him with message $m_{AB}$, and $id_A$.
            \item \textbf{Verify.} Bob needs to verify Alice's identity using $id_A$ and $m_{AB}$, say by checking Alice's profile. Bob now chooses to accept or reject the invitation.
        \end{enumerate}

    \medskip

      \textbf{Accept Invitation.}
          If Bob accepts Alice's invitation, he needs to respond to Alice.
          \begin{enumerate}
              \item \textbf{Decode.} Bob decodes $id_A = (ki_A^P, kx_A^P, i_A)$. He computes the shared secret $sk =  \DH(kx_B^P, kx^S_A)$ with Alice. He adds $i_A$ to the list of indices he listens to.
              \item \textbf{ACK.} Bob recieves the invitation message from Alice, $inv_{AB}$. Bob ACK's the message.
              \item Alice sees the ACK from Bob and now they can communicate over the PIR transport layer.
          \end{enumerate}
    \medskip
          
      \textbf{Reject Invitation.}
        If Bob rejects the invitation, no further action needs to be performed.
  \end{hangparas}
  }
  \end{framed}
  \caption{Anysphere's protocol for establishing trust when the participants are remote. Contact can be initiated only by a single participant and requires acknowledgement from both participants to establish successful contact}
  \label{fig:trust-establishment-async}
\end{figure}


\subsection{Asynchronous Invitation}

Our second method targets the case when Bob does not know about Alice's invitation beforehand. For example, Alice can be a sensitive client who wishes to privately reach out to Bob's company. 

This method consists of three steps. First, Alice sends an encrypted invitation to the server without indicating its recipient. Second, Bob retrieves this invitation via a full database download. Third, Bob informs Alice of his acceptance via an ACK message. This is described in detail in \cref{fig:trust-establishment-async}.

To send an invitation, Alice learns Bob's information through a public platform like Twitter. If Bob is a security-conscious firm, he might have also posted his Anysphere ID on his website. Alice can quickly import Bob's keys and needs to send two messages. One is an invitation through the Invitation Database for Bob to find her information and a second message through the PIR transport layer for Bob to acknowledge.

To retrieve an invitation, Bob periodically downloads the entire Async Invitation Database and notices if there are invitations for him. 
We address the question of the size of the database later in the section. 
The user(s) representing Bob's account can then choose whether to respond to the message, as would be the case in a traditional e-mail. If they choose to respond, they acknowledge Alice's message and can send a reply over the PIR transport layer.

This method achieves metadata security. We hide the timing of the invitation by making the daemon send to and download \textbf{AsyncInvitationDatabase} on a fixed schedule. 
We hide the recipient of Alice's request since our encryption scheme is key private(\todo{Cite Arvid's section}). 

This method offers a convenient trust establishment on par with most existing messaging platforms. 
Its disadvantage is that downloading the entire database is expensive. 
We estimate that a key-value pair in the \textbf{AsyncInvitationDatabase} take approximately $200\text{B}$. 
If we have 1 million users, the whole database will have a size of approximately $200\text{MB}$.
Thus, an individual user might wish only to download the database once or twice daily, which saves bandwidth but delays the detection of invitations. 
On the other hand, a company user could afford to download the database every second, which takes $200\text{MB}/s$ download bandwidth but can ensure incoming asynchronous invitations get detected almost instantly.

Finally, we note that this method introduces more attack vectors. For example, an attacker might use social engineering to make Alice believe that a fake $id_B$ belongs to Bob or simply monitor $A$'s traffic to $B$'s public profile. Therefore, we recommend that privacy-conscious users use face-to-face invitations whenever possible.

\xxx[Arvid]{Handle the part where we have to deal with Key Privacy.}